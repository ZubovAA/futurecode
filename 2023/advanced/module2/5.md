## Продолжение ДП
```
Задача поиска наибольшей возрастающей подпоследовательности
Задача поиска наибольшей общей подпоследовательности
```

Рассказать, что такое подпоследовательность, и в чем отличие от подотрезка. Сколько всего подпоследовательностей в массиве из n элементов. И насколько быстрее будут работать наши алгоритмы.

НВП:

Тут 3 алгоритма

1. Самый простой за квадрат
2. За O(n*log(C))
3. За O(n*log(n)) - с бинпоиском

Давайте расскажем все 3.

Тут всё по классике, алгоритм, его время работы, сколько памяти занимает. База динамики и переходы. Где лежит ответ.

Первый и третий легко гуглятся. Второй получается из первого.

dp[i] = макс длина нвп, которая заканчивается в i-ом элементе.

$dp[i] = max(dp[j]) + 1 | j : a[j] < a[i]$

Такой `j` можно искать линейно, тогда это вариант 1.

А вот вариант 2. :

Давайте хранить ДО на значениях a[index](именно что не на индексах, как обычно, а на всей числовой прямой). А именно, в элементе `x` ДО будем хранить $max(dp[i]) |  i : a[i] == x$. Т.е. рассмотрели все `a[i]`, такие, что `a[i] = x`. Среди них запомнили самый большой `dp[i]`.

Получаем ДО на максимум. Обновляем его с каждой итерацией алгоритма. Скорее всего придется делать его динамическим(тк значения элементов могут быть большими), но это проходили на предыдущем уроке.

НОП:

Тут просто рассказать алгоритм по тем же правилам.

Ко всем версиям того, что написано нужно добавить пункт про восстановление ответа.