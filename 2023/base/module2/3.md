_В этом уроке мы рассказываем, как устроены некоторые контейнеры, но пока их код не пишем. Оставим это дело до 3 модуля._

# vector

Вектор уже встречался в предыдущих занятиях, сейчас же цель -- разобраться в его работе изнутри.

Вектор - это массив изменяемой длины. Пусть `size` -- текущий размер вектора. У его элементов есть порядок, а именно у каждого из них есть свой индекс. Индексы идут от `0` до `size - 1`. Началом вектора считается элемент с индексом `0`, концом -- элемент с индексом `size - 1`.

Под изменяемой длиной подразуемевается несколько конкретных операций с вектором:

1. `resize(new_size)`: если `size` < `new_size`, то добавить в конец столько элементов, чтобы размер вектора стал `new_size`. Если размер `size` > `new_size`, то удалить с конца вектора столько элементов, чтобы размер стал равен `new_size`
2. `push_back(x)`: добавить в конец вектора элемент `x`
3. `pop_back()`: удалить последний элемент вектора
4. `insert(index, x)`: добавить элемент `x` в вектор таким образом, чтобы он стоял на индексе `index`

Отдельный вопрос, каким именно образом можно добиться увеличения памяти, и за сколько времени работает каждая из операций выше.


Идея в следующем, давайте выделим сразу какое-то количество памяти, даже если столько пока не требуется для хранения элементов. Выделять память будем динамически, поэтому будем хранить указатель на выделенную память и её размер. размер выделенной памяти будем хранить в поле `capacity`. Еще нужно хранить сколько памяти уже задействовано на хранение элементов, делать это будем в поле `size`.

Пример: `capacity` = 10, `size` = 4. Это значит, что в векторе выделено памяти под хранение 10 элементов. Но действительно там сейчас есть только 5 элементов, их индексы 0, 1, 2, 3. Значит, у нас есть еще 6 мест для новых переменных. При этом пользователь нашего класса знает лишь, что в нем хранится 4 элемента. Что выделено место под 10 переменных ему знать не обязательно.

Начнем писать код. Резервируем память в конструкторе, не забываем удалить её в дестукторе. Метод `Аt` возвращает `index`-ый элемент массива

Как тогда реализовать `push_back`? Пока поступим следующим образом: если `size` < `capacity`, т.е. еще есть свободные места, то просто добавим в конец уже существющим элементам новый элемент.

Но что делать, если вся память уже израсходована? Нужно её выделить заново, но уже больше. Тогда в новую нужно перенести содержимое старой и удалить ненужную. Более того, давайте если `size` = `capacity`, то выделять будем размера `2 * capacity`. Эту процедуру реализуем в SetNewCapacity. Тогда остаётся в начале `push_back` просто проверить, нужно ли увеличивать размер или нет.

## Время работы push_back

Обсудим время работы `push_back`. Всякий раз, когда $capacity > size$, мы просто записываем элемент на нужный индекс, т.е. тратим ~ 1 действие. Но вот если выделенной памяти не хватает, то нам приходится выделять её заново. Причем выделяем мы $2 * size$ новой памяти. С другой стороны, это происходит довольно редко. Поэтому точно ответить на вопрос, сколько работает этот метод, не получится. Это напрямую зависит от его текущих $size$ и $capacity$.

Но мы можем сказать, сколько в среднем он работает. В среднем означает следующее, давайте $M$ раз вызовем `push_back`, посчитаем, сколько суммарно действий мы сделали - $Total$, и поделим $Total$ на $M$.

Итак, за $M$ действий мы $M$ раз добавляли элемент, и еще сколько то раз выделяли память. Суммарно можно оценить выделенную память сверху вот таким числом $1 + 2 + 4 + 8 + ... + 2^k$. Степени 2-ки здесь из-за того, что каждый раз мы просим память в 2 раза больше, чем раньше. При этом $k$ такое максимальное, что $2^k \leq M$.

Но $1 + 2 + 4 + 8 + ... + 2^k = 2^{k+1} - 1 \leq 2 * M - 1 \leq 2 * M$

Итого, $M$ действий на добавление элементов, $2*M$ действий на выделение, $Total = 3 * M$. В среднем $\frac {Total}{M} = \frac {3 * M}{M} = 3 = O^*(1)$

$O(1)$ пишут, когда метод работает за не дольше, чем какое-то константное кол-во действий

В нашем векторе мы получили число 3, если посчитать более аккуратно, то получится чуть меньшее число, но все это означает, что на каждый `push_back` в среднем тратится совсем немного времени.

## Итераторы в векторе

Вспомним, что умеют указатели. 

```c++
int arr[10];
int i = 5;
int* ptr = &arr[i]; // можно писать arr + i -- адрес i-ого элемента
```

с `ptr` можно делать следующее:

1. `ptr + k` -- сдвинуть адрес на k вперед
2. `k + ptr` -- сдвинуть адрес на k вперед
3. `ptr - k` -- сдвинуть адрес на k назад
4. `++ptr` -- сдвинуть адрес на 1 вперед
5. `--ptr` -- сдвинуть адрес на 1 назад
6. `ptr++` -- сдвинуть адрес на 1 вперед
7. `ptr--` -- сдвинуть адрес на 1 назад

Сдвигая адрес, мы по сути переходим от одних элементов к другим в массиве

Хочется подобный инструмент, но не для массива, а для контейнеров таких как вектор.

И они есть, называются итераторы.

```c++
std::vector<int> vec;
```
Пусть есть некоторый вектор.

Тогда можно получить итератор на его первый элемент с помощью метода `begin`:

```c++
auto iter = vec.begin();
```

Итератор, это специальный объект, работа с которым очень похожа на указатель, а именно:

Можно разименовывать:
1. `*iter` -- значение элемента, на который указывает итератор

Можно прибавлять числа

1. `*iter` -- первый элемент вектора

2. `*(iter + 1)` -- второй элемент вектора

3. `*(iter + 2)` -- третий элемент вектора

4. и.т.д.

Можно изменять сам итератор:

1. `++iter`  - итератор на следующий элемент.
1. `iter++`  - итератор на следующий элемент.
1. `--iter`  - итератор на предыдущий элемент.
1. `iter--`  - итератор на предыдущий элемент.

Для лучшего понимания давайте рассмотрим 2 примера, в первом переберем все элементы классического массива с помощью указателей, а во втором -- все элементы вектора с помощью итератора

```c++
int arr[10];
int* ptr = arr;
int n = 10;
for (int i = 0; i < n; ++i) {
    *ptr = i;
    ++ptr;
}

for (int i = 0; i < n; ++i) {
    std::cout << arr[i] << " ";
}
```
Вывод:
```
0 1 2 3 4 5 6 7 8 9
```

```c++
std::vector<int> vec(10);
auto iter = vec.begin();
int n = 10;
for (int i = 0; i < n; ++i) {
    *iter = i;
    ++iter;
}

for (int i = 0; i < n; ++i) {
    std::cout << arr[i] << " ";
}
```
Вывод:
```
0 1 2 3 4 5 6 7 8 9
```

В случае вектора итератор это то же, что и указатель на элементы.

К слову, у итераторов есть свои типы, но они записываются довольно сложно, поэтому обычно пишут слово `auto`. Если без него, то тип на самом деле такой:

```c++
std::vector<int>::iterator iter = vec.begin();
```

Также у вектора и почти всех других контейнеров, что мы рассмотрим, есть метод `end()`. Он возвращает итератор, но не на последний элемент, как могло показаться, а итератор на элемент, идущий после последнего(Да, такого нет, но представьте, будто есть). Т.е. `end()` -- метка конца всех элементов, и если какой-то итератор равняется `end()`, мы дошли до конца контейнера. Давайте переберем элементы вектора, используя `begin` и `end`:

```c++
std::vector<int> vec(10);
auto last = vec.end();
for (auto iter = vec.begin(); it != last; ++it) {
    *iter = i;
}
```

Как получить итератор не на первый элемент, а на `i`-ый? Просто прибавить к `vec.begin()` число `i`:
```c++
auto it = vec.begin() + i;
```


Может, показаться, что итераторы не особо и нужны. Действительно, они делают ровно то, что и указатели. Оказывается, это хоть и верно для `std::vector`, но вот для других контейнеров это уже не так. В следующем стандартном контейнере, который мы рассмотрим, `std::list`, уже нельзя пользоваться ни указателями, ни индексами элементов. И без итераторов его элементы уже никак не перебрать. 


Но пока давайте до конца разберемся с итераторами в векторе, и что можно с ними делать.

Мы говорили _итератор на элемент_, но правильнее было бы говорить, что итератор связан не с элементом, а с позицией в векторе. Приняв такую интерпритацию, можно перейти к последнему незатронотому методу вектора. 

При реализации вектора мы задались несколькими вопросами, и последний из них был, как вставлять элемент не в конец вектора, а в произвольную позицию. Это умеет делать метод `insert(итератор iter, элемент x)`. Пусть итератор указывает на индекс `i`. Тогда `x` будет вставлен так, чтобы оказаться на индексе `i`. При этом все элементы правее этого индекса, будут на 1 сдвинуты вправо.

Посмотрите на пример:


```c++
void printVector(std::vector<int>& vec) {
    std::cout << "Vector size is " << vec.size() << "\nVector elements are: ";
    for (unsigned int i = 0; i < vec.size(); ++i) {
        std::cout << vec[i] << " ";
    }
    std::cout << "\n";
}

int main() {
    std::vector<int> vec(4, 1);
    printVector(vec);
    vec.insert(vec.begin(), 100);
    printVector(vec);
    vec.insert(vec.begin() + 2, 200);
    printVector(vec);
}
```
Вывод:
```
Vector size is 4
Vector elements are: 1 1 1 1 
Vector size is 5
Vector elements are: 100 1 1 1 1 
Vector size is 6
Vector elements are: 100 1 200 1 1 1 
```

Получается, в общем случае, строчка

```c++
vec.insert(vec.begin() + index, x);
```

вставит `x` на позицию `index`.

За сколько работает такая операция? Если размер вектора `size`, а вставляем мы на позицию `index`, то нужно сдвинуть вправо как минимум `size - index - 1` элементов, а порой еще дополнительно выделить память. При этом, если `index` == 0, то сдвинуть нужно целых `size` элементов, что для больших векторов будет стоить много. Поэтому, методом insert пользуются только либо для маленьких векторов, либо если вставка происходит ближе к концу вектора.

К слову, у `insert` есть и возвращаемое значение. Это пара (`bool`, `std::vector<T>::iterator`). Первое -- получилось ли вставить, а второе -- итератор на вставленный элемент. 

Также предлагается обсудить, как использовать функцию std::sort с вектором и итераторами.

# list

`#include <list>`


Вектор позволял хранить элементы последовательно. Причем, добавлять новые за $O(1)$ мы могли только в конец вектора. При этом также за $O(1)$ был доступ к любому элементу по индексу. Добавлять элементы в начало можно за $O(n)$.

`std::list` позволяет добавлять элементы как в конец, так и в начало за $O(1)$. Также можно и удалять как с конца, так и из начала за $O(1)$. За это мы платим тем, что не можем больше обращаться к элементу по индексу, и в целом, доступ к произвольному элементу осуществляется за $O(n)$, с некоторой оговоркой.


Синтаксис:

```c++
std::list<Тип> myList;
std::list<Тип> myListWithElements({5, 6, 7, 101});
```

Методы:

1. `push_back(x)` -- добавит элемент в конец листа
2. `push_front(x)` -- добавит элемент в налало листа
3. `pop_back()` -- удалит последний элемент
4. `pop_front()` -- удалит первый элемент
5. `size()` -- текущий размер
6. `begin()` -- итератор на первый элемент
7. `end()` -- итератор на конец листа(элемент после последнего)
8. `front()` -- первый элемент
9. `back()` -- последний элемент
10. `insert(iter, x)` -- вставит элемемент по итератору
11. `erase(iter)` -- удалит элемент по итератору

Все перечисленные методы работают за $O(1)$.

При этом, как видно из методов, мы не можем пока перебирать элементы так, как делали это раньше. Тут нам помогут итераторы. А именно:

```c++
std::list<Тип>::iterator iter = lst.begin();
```
В начале получаем итератор на первый элемент. Затем с помощью него можно перебрать все элементы в листе.

Итераторы std::list умеют намного меньше, чем итераторы std::vector

1. `++iter`  -- можно
2. `--iter`  -- можно
3. `iter++`  -- можно
4. `iter--`  -- можно
5. `iter +- k`  -- нельзя
6. `k +- iter`  -- нельзя
7. `iter1 - iter2`  -- нельзя
8. `iter[index]` -- нельзя

Поэтому, в частности, чтобы получить элемент с индексом `index`, нужно написать что-то в таком духе:

```c++
template<typename T>
T& AtIndex(std::list<T>& myList, unsigned int index) {
    auto iter = myList.begin();
    for (unsigned int i = 0; i < index; ++i) {
        ++iter;
    }
    return *iter;
}
```

Поэтому в общем получение `index`-ого элемента происходит за $O(n - index)$. Пишут обычно $O(n)$, т.к. `index` может быть любым.

В то же время, если уже есть итератор на `index`-ый элемент, то можно произвести вставку/удаление на позиции `index`:

```c++
template<typeaname T>
std::list<T>::iterator IterAtIndex(const std::list<T>& myList, unsigned int index) {
    auto iter = myList.begin();
    for (unsigned int i = 0; i < index; ++i) {
        ++iter;
    }
    return iter;
}
```

```c++
int main() {
// ...
    unsigned int index;
    std::cin >> index;
    int value;
    std::cin >> value;
    auto iter = IterAtIndex(myList, index);
    myList.insert(iter, value);
}
```

```c++
int main() {
// ...
    unsigned int index;
    std::cin >> index;
    auto iter = IterAtIndex(myList, index);
    myList.erase(iter);
}
```

В этих примерах мы вызываем функцию, которая возвращает итератор за $O(n)$, но именно вставка/удаление происходит за $O(1)$.

--------

Как `std::list` устроен внутри, и почему на него накладываются такие ограничения.

Мы не будем рассматривать полную реализацию, но опишем, как примерно она выглядит. 

Представьте следующую ситуацию, $n$ людей стоят в ряд, все смотрят в одну сторону. Каждый из них знает только своего соседа спереди и сзади. Также каждый их них хранит некий элемент(как раз таки элемент на позиции). Еще иногда приходят новые люди, которые хотели бы встать либо в начало очереди (`push_front`), либо в конец (`push_back`). Поэтому вам необходимо хранить соответственно первого и последнего человека(если они вообще есть), чтобы поставить нового человека на нужное место. Это можно было бы описать такой структурой:

```c++
struct Node {
    Node* prev;
    Node* next;
    int value;
};
```
Где `prev` хранит указатель на соседа сзади, а `next` -- на соседа спереди.

`Node` как раз и олицетворяет человека из примера. Также нужно создать `Node` на фиктивный элемент, чтобы производить вставку в начало и конец.

В самом начале у вас пустой лист, поэтому есть только 2 объекта `Node` -- фиктивный первый и фиктивный последний.

Проинициализировать можно так, 0 означает, что такого элемента нет:

```c++

Node* FakeFirst = new Node;
Node* FakeLast = new Node;

FakeFirst->prev = 0;
FakeFirst->next = FakeLast;
FakeLast->prev = FakeFirst;
FakeLast->next = 0;
```

_Примечание_: `оператор ->` это упрощение следующего кода:

```c++
(*FakeFirst).next = FakeLast; // Можно писать так
FakeFirst->next = FakeLast; // То же самое
```

Т.е. `->` сначала применяет `*` к объекту, а затем обращается к методу.


Напишем `push_front`:

```c++
void PushFront(int x) {
    Node* newNode = new Node;
    newNode->value = x;
    Node* currentFirst = FakeFirst->next;
    FakeFirst->next = newNode;
    newNode->prev = FakeFirst;
    newNode->next = currentFirst;
    currentFirst->prev = newNode;
}
```

и `push_back`:

```c++
void PushBack(int x) {
    Node* newNode = new Node;
    newNode->value = x;
    Node* currentLast = FakeLast->prev;
    FakeLast->prev = newNode;
    newNode->next = FakeLast;
    newNode->prev = currentLast;
    currentLast->next = newNode;
}
```

# deque

# deque

`#include <deque>`

Представьте контейнер, который хранит элементы последовательно, умеет вставлять как в начало, так и в конец за $O(1)$, более того получать произвольный элемент также за $O(1)$. Получится `std::deque`.

Синтаксис:

```c++
std::deque<Тип> myDeque;
std::deque<Тип> myDequeWithElements({5, 6, 7, 101});
```

Методы:

1. `push_back(x)` -- добавит элемент в конец листа
2. `push_front(x)` -- добавит элемент в налало листа
3. `pop_back()` -- удалит последний элемент
4. `pop_front()` -- удалит первый элемент
5. `size()` -- текущий размер
6. `begin()` -- итератор на первый элемент
7. `end()` -- итератор на конец листа(элемент после последнего)
8. `front()` -- первый элемент
9. `back()` -- последний элемент
10. `operator[index]` -- вернет `index`-ый элемент

Все эти методы работают за $O(1)$.

Также есть:

11. `insert(iter, x)` -- вставит по итератору
12. `erase(iter)` -- удалит по итератору

Эти методы работают за линейное время от $min(x, n - x)$.

У `deque` также есть и итераторы, они умеют делать почти то же, что и в векторе:

1. `++iter`  -- можно
2. `--iter`  -- можно
3. `iter++`  -- можно
4. `iter--`  -- можно
5. `iter +- k`  -- можно
6. `k +- iter`  -- можно
7. `iter1 - iter2`  -- можно
8. `iter[index]` -- можно

Внимательный читатель заметит, что пока `deque` умеет все, что и вектор, при этом справляется с вставкой в начало за $O(1)$, в то время как вектору нужно $O(n)$ на это. На самом деле за такие возможности `deque` платит эффективностью. А именно, `operator[]` у вектора работает быстрее, чем у `deque`. Также у вектора элементы лежат последовательно, поэтому можно работать как с итераторами, так и с указателями на элементы. У `deque` это не так.

Пример работы и вывода:

```c++
std::deque<int> dq;

dq.push_back(5);
dq.push_front(4);
dq.push_front(2);

for (unsigned int i = 0; i < dq.size(); ++i) {
    std::cout << dq[i] << " ";
}
std::cout << "\n";

dq.push_front(1);

for (auto it = dq.begin(); it != dq.end(); ++it) {
    std::cout << *it << " ";
}
std::cout << "\n";

dq.insert(dq.begin() + 2, 3);

auto iter = dq.begin();
for (unsigned int i = 0; i < dq.size(); ++i) {
    std::cout << iter[i] << " ";
}
std::cout << "\n";
```

Вывод:

```
2 4 5 
1 2 4 5 
1 2 3 4 5 
```

# range-based for loop

Не все контейнеры позволяют обращаться к элементам по индексу, например `std::list`. К тому же иногда нужно просто перебрать сами элементы, и не очень хочется создавать для этого отдельные объекты под итераторы или индексы. `range-based for` позволяет делать это напрямую.

Посмотрите на цикл с итераторами

```c++
for (auto iter = container.begin(); iter != container.end(); ++iter) {
    auto value = *iter;
    // Действия с value, например вывод на экран
}
```

`range-based for` это особый вид цикла `for`. Он позволяет не писать подобную логику с итераторами.

У него свой синтаксис, в общем виде его можно записать так:

```c++
for (auto value : container) {
    // Действия с value, например вывод на экран
}
```

`value` с каждой новой итерацией цикла будет принимать значение очередного элемента вашего контейнера.

-------

Посмотрите примеры:

```c++
std::vector<int> myVector({1, 2, 3, 4, 5});
for (auto x : myVector) {
    std::cout << x << " ";
}
```

Вывод:

```
1 2 3 4 5
```

-------


```c++
std::list<int> myList({1, 2, 3, 4, 5});
for (auto x : myList) {
    std::cout << x << " ";
}
```

Вывод:

```
1 2 3 4 5
```

------

```c++
std::list<int> myDeque({1, 2, 3, 4, 5});
for (auto x : myDeque) {
    std::cout << x << " ";
}
```

Вывод:

```
1 2 3 4 5
```

------


Работает даже с массивами константной длины:

```c++
int myArray[] = {1, 2, 3, 4, 5};
for (auto x : myArray) {
    std::cout << x << " ";
}
```

Вывод:

```
1 2 3 4 5
```

------

Пара уточнений

Вместо `auto` можно писать тип, который хранится в контейнере или массиве. В примерах выше -- это `int`.

Также, если просто писать `auto`, то мы получим копии на элементы контейнера, а не сами элементы. Если нужны сами объекты, нужно просто использовать ссылочный тип `auto&`

```c++
std::vector<int> myVector({1, 2, 3, 4, 5});

for (auto x : myVector) {
    x *= 2; // Не меняет реальные элементы вектора
}

for (auto x : myVector) {
    std::cout << x << " ";
}
std::cout << "\n";

for (auto& x : myVector) {
    x *= 2; // Меняет реальные элементы вектора
}

for (auto x : myVector) {
    std::cout << x << " ";
}
std::cout << "\n";
```

Вывод:

```
1 2 3 4 5 
2 4 6 8 10
```