# stack и queue

`stack` это контейнер, который хранит элементы последовательно, и позволяет за $O(1)$ вставлять в конец, удалять последний, получать доступ к последнему элементу. 

`queue` это контейнер, который хранит элементы последовательно, и позволяет за $O(1)$ вставлять в конец, удалять первый, получать доступ к первому элементу.

Запомнить можно так:

`queue` переводится как `очередь`. Когда люди встают в очередь, они встают именно в её конец. Когда человек выходит из очереди, он выходит именно из её начала. `FIFO` -- _first in first out_.

`stack` можно представить как стопку тарелок, которые необходимо помыть. Вы моете посуду и обычно берете тарели все-таки сверху. И когда кладут новые тарелки, их тоже обычно ставят наверх. `FILO` -- _first in last out_.

Теперь перейдем непосредственно к `stack` и `queue` в С++.

Как вы могли заметить, все, что требуется от этих двух структур, уже умеет замечательный контейнер `deque`. Разработчики языка тоже это заметили, поэтому стандартные `stack` и `queue` используют внутри себя `deque`. Причем используют его довольно конкретно, он передается в качестве шаблонного параметра:

```c++
template<class T, class Container = std::deque<T>>
class stack;
```

и 

```c++

template<class T, class Container = std::deque<T>>
class queue;
```

`deque` указан, как шаблонный параметр по умолчанию, поэтому его можно не писать при объявлении класса. Однако вы можете передать и свой собственный класс, главное, чтобы он соответствовал требованиям `stack` и/или `queue`.

Ровно по этой причине стандартные `stack` и `queue` по времени работают столько же, сколько и `deque`. Поэтому его можно использовать вместо этих двух без потери эффективности. 

Рассмотрим все же их детально:


----


# stack

`#include <stack>`

Синтаксис:

```c++
std::stack<Тип> myStack;
std::stack<Тип> myStackWithElements({5, 6, 7, 101});
```

Методы:

1. `push(x)` -- то же, что и `push_back(x)`
2. `pop()` -- то же, что и `pop_back()`
3. `top()` -- то же, что и `back()`
4. `size()` -- размер

У стека нет итераторов. Его используют только в тех задачах, в которых его функционала достаточно.

Также, из-за того что стандартный `stack` основан на `deque`, иногда вместо `stack` используют `vector`. Действительно, `vector` умеет делать всё, что требует `stack`. Да и работает он быстрее, чем `deque`.


# queue

`#include <queue>`

Синтаксис:

```c++
std::queue<Тип> myQueue;
std::queue<Тип> myQueueWithElements({5, 6, 7, 101});
```

Методы:

1. `push(x)` -- то же, что и `push_back(x)`
2. `pop()` -- то же, что и `pop_front()`
3. `front()` -- первый элемент
4. `back()` -- последний элемент
5. `size()` -- размер

У очереди нет итераторов. Её используют только в тех задачах, в которых её функционала достаточно.

---

Итого было рассмотрено 5 контейнеров. 

`std::vector`, `std::list`, `std::deque`, `std::stack` и `std::queue`. Выбирайте контейнер исходя из того, что требует та или иная задача.

Все эти контейнеры хранят элементы последовательно. Разница в том, что именно мы требуем от контейнера. Чем больше требования, тем сложнее или дольше он будет работать.

# ДП


По началу детям может быть сложно думать о задачах ДП в правильном формате. Предлагается следующий вариант мышления. Когда ученик решает задачу на дп ему нужно ответить на эти вопросы:

1. Как хранятся данные
2. Где в этих данных лежит ответ
3. Какая база у динамики, а именно, какие значения мы уже знаем и не можем получить по переходам
4. Какая функция перехода в ДП
5. Как правильно перебирать данные из исходной задачи

Рассмотрим пример, найти n-ое число Фиббоначи

1. Данные будем хранить в массиве dp[1...N];
2. n-ное число фиббоначи это dp[n]
3. dp[1] = 1, dp[2] = 1
4. dp[i] = dp[i - 2] + dp[i - 1]
5. перебираем i от 3 до N.

Следующий вопрос, как хранить массив dp.
Тут несколько вариантов. Обычно в задаче сразу прописаны ограничения, поэтому вы можете объявить этот массив глобально, вопрос лишь в том, какого размера массив должен быть. Для этого создают константную переменную такого размера, что его точно хватит из ограничений задачи.

Или же создают std::vector, локально или глобально, и сразу указывают нужный размер.

Заметим, что с точки зрения _скорости_ и _производительности_, использование вектора - плохое решение, и самые быстрые посылки будут достигаться с объявленными глобально массивами. Причиной этому является то, что любые глобально объявленные объекты создаются еще на этапе компиляции, да и сам std::vector имеет скрытую константу в реализации.

Можно заметить, что всё дп построено на математической индукции.

ДП такая тема, что она познается в решении задач. Поэтому всё занятие нужно будет разбирать задачи. В каждой из них необходимо проделать путь с ответами на вопросы выше и посчитать сложность алгоритма. Когда дойдете до восстановления ответа, вернуться к задачам и рассказать для них, как он восстанавливается.

Рассказать и решить задачи отсюда:

# Одномерное ДП

[ссылка](https://wiki.algocode.ru/index.php?title=%D0%9E%D0%B4%D0%BD%D0%BE%D0%BC%D0%B5%D1%80%D0%BD%D0%BE%D0%B5_%D0%94%D0%9F)


# Двумерное ДП

[ссылка](
https://wiki.algocode.ru/index.php?title=%D0%94%D0%B2%D1%83%D0%BC%D0%B5%D1%80%D0%BD%D0%BE%D0%B5_%D0%94%D0%9F_:_%D1%87%D0%B5%D1%80%D0%B5%D0%BF%D0%B0%D1%88%D0%BA%D0%B0)