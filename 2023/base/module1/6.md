# Указатели и ссылки


_Ключевая тема, уделить ей особенное внимание._

__Указатели__

Каждая переменная, которую вы создаете(кроме возможно некоторых констант), лежит в оперативной памяти. А значит, у нее есть адрес. Почти на всех современных компьютерах этот адрес записывается 64 битам, т.е. 8 байтами. Для адреса в памяти существуют отдельные типы, которые хранят этот самый адрес.

Если переменная `x` имеет тип `Type`, то её адрес можно хранить в переменной типа `Type*`. Такие переменные называют указателями.

```c++
#include <iostream>

int main() {
    int x = 0;
    int* ptr_int; // В этой переменной можно хранить адрес любого int
    double* ptr_double; // В этой переменной можно хранить адрес любого double
    char* ptr_for_symbol; 
    std::cout << sizeof(ptr_int); // Будет 8
}
```
Как получить адрес переменной? Для это есть унарный оператор `&`
```c++
#include <iostream>

int main() {
    int x = 0;
    int* ptr_int = &x;
    double y = 3.14;
    double* ptr_double = &y;
}
```

Как вывести адрес? С этим справится обычный `cout`. Только нужно помнить, что он выводит адреса в 16-ричном формате.

```c++
#include <iostream>

int main() {
    int x = 0;
    int* ptr_int = &x;
    std::cout << ptr_int << "\n";
    double y = 3.14;
    double* ptr_double = &y;
    std::cout << ptr_double << "\n";
}
```
_Уточнение_: Если попытаетесь так вывести адрес переменной типа `char`, то адрес вы не увидите. Это связано с тем что тип `char*` используется немного в другом контексте, а именно для C-style строк.

А если у вас есть адрес переменной, то как получить то, что под ним лежит, т.е. саму переменную?

Для этого есть унарный оператор `*`, который применяют к указателю(говорят, что указатель разыменовывают)


```c++
#include <iostream>

int main() {
    int x = 15;
    int* ptr_int = &x;
    std::cout << ptr_int << "\n";
    std::cout << *ptr_int << "\n"; // Выведет 15
    x += 1;
    std::cout << *ptr_int << "\n"; // Выведет 16
    double y = 3.14;
    double* ptr_double = &y;
    std::cout << ptr_double << "\n";
    std::cout << *ptr_double << "\n"; // выведет 3.14
    y = 0;
    std::cout << *ptr_double << "\n"; // выведет 0
}
```

Применяя `*` к указателю вы получаете ту переменную, на которую он ссылается, поэтому в частности можно делать так:
```c++
#include <iostream>

int main() {
    int x = 15;
    int* ptr = &x;
    *ptr = 2; // Все равно что написать x = 2
    std::cout << x; // Будет 2
}
```
Базовые операции с указателем:
1. унарный *
2. +- число
3. - указатель

1 уже был рассмотрен, далее 2 и 3:

_Далее предполагается, что стек у вас направлен положительно, т.е. чем позже объявлена переменная, тем больший у неё адрес. Не везде это так(Например, Windows)_

```c++
#include <iostream>

int main() {
    int x = 15;
    int y = 3;
    int z = 100;
    std::cout << &x << "\n" << &y << " " << &z << "\n";
}
```
Вы получите 3 строчки адресов, но можно заметить, что все они идут через 4 в 16-ричном формате. Это связано с тем, что размер `int` - 4 байта, и эти переменные идут в памяти подряд. Поэтому можно делать так:

```c++
#include <iostream>

int main() {
    int x = 15;
    int y = 3;
    int z = 100;
    std::cout << &x << "\n" << &y << " " << &z << "\n";
    std::cout << &z - &y << "\n"; // 1
    std::cout << &z - &x << "\n"; // 2
    std::cout << &y - &x << "\n"; // 1
}
```
Еще один факт, указатели на тип размера `k` байт обязательно принимают значения адресов кратных `k`. Например, адреса `int` кратны 4.


Как видно `ptr1 - ptr2` это расстояние между указателями, но не в байтах. А в кол-ве переменных, которые между ними лежат.

Т.е. `ptr1 - ptr2` = `Расстояние в байтах` / `Рамер типа в байтах`

Отсюда понятно, как работает `ptr +- число`
```c++
#include <iostream>

int main() {
    int x = 15;
    int y = 3;
    int z = 100;
    int* ptr = &z;
    std::cout << ptr << "\n"; // Адрес z
    std::cout << *ptr << "\n"; // 100
    std::cout << ptr - 1 << "\n"; // Адрес y
    std::cout << *(ptr - 1) << "\n"; // 3
    std::cout << ptr - 2 << "\n"; // Адрес x
    std::cout << *(ptr - 2) << "\n"; // 15
}
```

Также писать `ptr1 - ptr2` можно только для указателей одного типа:
```c++
#include <iostream>

int main() {
    int x = 15;
    int* ptr_int = &x;
    double y = 3.14;
    double* ptr_double = &y;
    std::cout << ptr_int - ptr_double << "\n"; // Тут CE
}
```

Тип `void*`

Как видно, независимо от типа указатель это адрес в памяти. Все указатели 64 - битны. Что если разработчик просто хочет хранить адрес без привязки к типу?

Для это есть `void*`
Но с ним несколько нюансов

```c++
#include <iostream>

int main() {
    int x = 15;
    void* ptr = &x; // В ptr лежит адрес x
    std::cout << ptr << "\n"; // Можно вывести адрес
    std::cout << ptr + 1 << "\n"; // Можно и так, но компилятор будет ругаться
    std::cout << *ptr << "\n"; // Так нельзя, void не содержит информацию о типе
    int* ptr_x = ptr; // Так тоже нельзя
}
```
Как мы уже обсудили, указатели разных типов несовместимы друг с другом. Вы можете преобразовывать указатель к `void*`. Но все остальные касты уже запрещены. 

Т.е. `void*` -> `int*`, `long long*` -> `double*` и т.п. Всё это уже писать нельзя, будет CE.

Но если очень хочется, то можно использовать `reinterpret_cast`, он как раз создан для таких случаев.

```c++
#include <iostream>

int main() {
    double x = 3.14;
    double* ptr = &x;
    long long* p = reinterpret_cast<long long*>(ptr);
    std::cout << *p;
}
```
Теперь `p` указывает на ту же область памяти, что и `ptr`. Но `p` считает, что там лежит `long long`, но на самом то деле там `double`. Поэтому разименовывая его мы получим число типа `long long`, с такими же битами, что и у числа `x`. Конечно, ничего хорошего от такого не стоит ожидать, но иногда это полезно.

Также стоит отметить следующее. Указатели это обычные переменные веса 8 байт. Значит, они лежат в памяти, как переменные. А значит, можно создать указатель на эту область памяти.
```c++
#include <iostream>

int main() {
    long long x = 3;
    long long* ptr = &x;
    long long** ptr_of_ptr = &ptr;
    std::cout << ptr << "\n " << ptr_of_ptr << "\n";
}
```
Указатель, это число в 16-ричном формате. Как получить само это число? Мы знаем, что оно весит 64 бита, причем беззнаковое. Т.е. это число типа unsigned long long.
Такой код адрес переводит в число:

```c++
#include <iostream>

int main() {
    int x = 5;
    void* ptr = &x;
    unsigned long long res = *reinterpret_cast<unsigned long long*>(&ptr);
    std::cout << ptr << "\n" << res << "\n";
}
```

Убедиться, что адреса типов размера k, действительно кратны k.


-------

__Ссылки__

Рассказать про обычные и немного про константные ссылки.

На начальном уровне детям можно объяснить, что ссылка на переменную `x`, это та же переменная `x`, только с другим именем. В будущих уроках будет показано, что это не совсем так.
```c++
#include <iostream>

int main() {
    int x = 5;
    int& y = x; // y -- ссылка на x
    std::cout << x << " " << y; // 5 5
    x += 1;
    std::cout << x << " " << y; // 6 6
    y += 1;
    std::cout << x << " " << y; // 7 7
}
```
Теперь `x` и `y` для нас одно и то же.

```c++
#include <iostream>

int main() {
    int x = 5;
    int& y; // CE, так нельзя, ссылка должна ссылаться на что-то
    int& z = 5; // CE, так тоже нельзя, ссылка должна ссылаться на переменную
}
```

Константные ссылки
```c++
#include <iostream>

int main() {
    int x = 5;
    const int& z; // CE, так нельзя, константная ссылка должна ссылаться на что-то
    const int& y = 6; // А вот так уже можно
    std::cout << y << "\n";
    const int& t = x;
    std::cout << x << " " << t << "\n";
    x += 1; // Так можно
    std::cout << x << " " << t << "\n";
    t += 1; // Так нельзя, ведь t - КОНСТАНТНАЯ ссылка
    std::cout << x << " " << t << "\n";
}
```

Стоит отметить, что сама ссылка, как объект, весит 8 байт.

# Динамическое выделение памяти

Все ваши данные в программе должны где-то храниться. До этого все переменные, что вы создавали, хранились в месте, которое называется `стек`. У него ограниченный размер, и его как раз и используют для локальных переменных. Еще есть область памяти, которая называется `heap(куча)`. По сути, это ваша оперативная память. Так вот она явно больше чем стек, и там очень часто аллоцируют данные большого размера

Для работы с кучей используют операторы `new` и `delete`

__`new` и `delete`__:

```c++
int* ptrx = new int; // Просим выделить память под переменую int
std::cout << ptrx << "\n";

double* ptry = new double(3.14); // Просим выделить память под переменую double, сразу приравниваем к 3.14
std::cout << ptry << "\n";
std::cout << *ptry << "\n";

delete ptrx; // Освобождаем запрошенную память
delete ptry;
```
Вывод
```
0x55fe5950eeb0
0x55fe5950f2e0
3.14
```

`new` возвращает указатель на память, где хранится ваша переменная. Можно сразу приравнять ей какое-то значение. Хорошей практикой является отдавать память, когда она вам больше не нужна. Для этого есть `delete`. После него пишите адрес, который вам когда-то вернул `new`. Освобождать память по какому-то адресу можно только один раз, дважды писать `delete` с одним и тем же указателем нельзя.

Также, помните, что `new` и `delete` -- дорогие операции они работают достаточно долго.


# Связь указателей и массивов

```c++
int arr[5];
```

На самом деле, имя массива можно расценивать как указатель на его первый элемент.

```c++
std::cout << arr << "\n" << &arr[0]; // Выведет два одинаковых адреса
```

К указателям можно прибавлять числа и вычитать. Пусть указазатель `ptr` был типа `T*`, а размер у самого типа `T` равен `k` байт, тогда `ptr + 1`, это тоже указатель на область памяти, которая сдвинута на k байт.

Массив arr хранит свои элементы последовательно, поэтому для него, в частности, верно:

1. `&arr[0] + 1 == &arr[1]`
2. `&arr[1] + 1 == &arr[2]`
3. `&arr[2] + 1 == &arr[3]`

И так далее.

Более того:

1. `arr == &arr[0]`
2. `arr + 1 == &arr[0] + 1 == &arr[1]`
3. `arr + 2 == &arr[0] + 2 == &arr[2]`
4. `arr + 3 == &arr[0] + 3 == &arr[3]`

Т.е. на самом деле верно, что `arr + i` == `&arr[i]`


Как тогда работают `[]` при обращении к массиву?

`arr[number]  ===  *(arr + number)`

Но если имя массива -- это все равно что указатель на его первый элемент, т.е.

```c++
int* ptr = arr;
```

то можно сделать прямое соответствие между массивами и указателями:


```c++
int arr[5];
int* ptr = arr;
``` 

1. `*ptr  ===  ptr[0]  === arr[0]   ===  *arr`
2. `*(ptr + 1)  ===  ptr[1]  ===  arr[1]  ===  *(arr + 1)`
3. `*(ptr + 2)  ===  ptr[2]  ===  arr[2]  ===  *(arr + 2)`
4. `*(ptr + 3)  ===  ptr[3]  ===  arr[3]  ===  *(arr + 3)`
5. `*(ptr + 4)  ===  ptr[4]  ===  arr[4]  ===  *(arr + 4)`

И, в целом, для любого индекса `i` верно :

`*(ptr + i)  ===  ptr[i]  === arr[i]  ===  *(arr + i)`

Здесь `===` не оператор языка, а просто обозначие, что эти выражения -- одно и то же.

К слову, отсюда же следует синтаксический сахар:

`ptr[i] === *(ptr + i) === *(i + ptr) === i[ptr]`

Просьба так не писать.

# operator new[], delete[]


Классические массивы создатся на стеке.

Но можно создать и в `heap`.

Для этого используют `new[]`

```c++
int* arr = new int[5]; // Создали массив на 5 переменных
arr[0] = 1; // Индексация идет с 0
arr[1] = 2; // Чтобы обратиться к переменной, используют []
arr[2] = 4; // 3 число
arr[3] = 8; // 4 число
arr[4] = 16;// 5 число
for (int i = 0; i < 5; ++i) {
    std::cout << arr[i] << " ";
}
delete[] arr;
```

На самом деле, код отличается только в том, как мы создаем массив. Дальше вы с ним работаете, как с обычным массивом. Только теперь он создан в `heap`, а не на стеке. Как и раньше, хороший тон -- освободить память, но с массивами это делает `delete[]`

Также теперь уже можно создавать массивы с длиной не константа:

_Задача_:
Вводится число `n`. Затем `n` чисел. Нужно вывести эти числа в обратном порядке.
```c++
int n;
std::cin >> n;
int* goodArray = new int[n];
for (int i = 0; i < n; ++i) {
    std::cin >> goodArray[i];
}
for (int i = n - 1; i >= 0; --i) {
    std::cout << goodArray[i] << " ";
}
delete[] arr
```

Ввод:
```
5
1 2 4 8 16
```
Вывод:
```
16 8 4 2 1
```
